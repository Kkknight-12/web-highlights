<!DOCTYPE html>
<html>
<head>
    <title>Error Handler Module Test</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        h2 { margin-top: 0; }
        pre {
            background: #f5f5f5;
            padding: 10px;
            overflow-x: auto;
            font-size: 12px;
        }
        button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
        }
        #stats-display {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 12px;
        }
        .error-entry {
            margin: 5px 0;
            padding: 5px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .error-type {
            font-weight: bold;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Chrome Web Highlighter - Error Handler Module Test</h1>
    
    <div class="test-section">
        <h2>Error Simulation</h2>
        <button onclick="simulateContextError()">Simulate Context Error</button>
        <button onclick="simulateDOMError()">Simulate DOM Error</button>
        <button onclick="simulateStorageError()">Simulate Storage Error</button>
        <button onclick="simulateSelectionError()">Simulate Selection Error</button>
        <button onclick="simulateHighlightError()">Simulate Highlight Error</button>
        <button onclick="simulateUnknownError()">Simulate Unknown Error</button>
        <div id="simulation-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Safe Execution Tests</h2>
        <button onclick="testSafeExecute()">Test Safe Execute</button>
        <button onclick="testSafeExecuteWithRetry()">Test Safe Execute with Retry</button>
        <button onclick="testWrapFunction()">Test Wrap Function</button>
        <div id="safe-exec-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Context Validation</h2>
        <button onclick="checkContext()">Check Extension Context</button>
        <button onclick="mockInvalidContext()">Mock Invalid Context</button>
        <button onclick="restoreContext()">Restore Context</button>
        <div id="context-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Error Statistics</h2>
        <button onclick="showStats()">Show Stats</button>
        <button onclick="clearHistory()">Clear History</button>
        <div id="stats-display"></div>
    </div>
    
    <div class="test-section">
        <h2>Automated Tests</h2>
        <button onclick="runAllTests()">Run All Tests</button>
        <div id="test-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Event Log</h2>
        <button onclick="clearEventLog()">Clear Log</button>
        <div id="event-log"></div>
    </div>

    <!-- Mock Chrome API -->
    <script>
        // Mock chrome API for testing
        if (typeof chrome === 'undefined') {
            window.chrome = {
                runtime: {
                    id: 'mock-extension-id',
                    getManifest: () => ({ version: '1.0.0' })
                },
                storage: {
                    local: {
                        get: (keys, callback) => callback({}),
                        set: (data, callback) => callback && callback()
                    }
                }
            };
        }
        
        // Original chrome reference for testing
        const originalChrome = window.chrome;
    </script>

    <!-- Load Constants first -->
    <script>
        // Mock Constants for testing
        const Constants = {
            IS_PRODUCTION: false,
            TIMING: {
                DEBOUNCE_DELAY: 300
            }
        };
    </script>

    <!-- Load the modules -->
    <script src="src/core/EventBus.js"></script>
    <script src="src/core/StateManager.js"></script>
    <script src="src/modules/errorHandler.js"></script>
    
    <script>
        // Test utilities
        function log(message, isError = false, targetId = 'test-results') {
            const element = document.getElementById(targetId);
            const div = document.createElement('div');
            div.className = isError ? 'error' : 'success';
            div.textContent = message;
            element.appendChild(div);
        }
        
        function logEvent(event, data) {
            const element = document.getElementById('event-log');
            const div = document.createElement('div');
            div.innerHTML = `<strong>${event}:</strong> ${JSON.stringify(data, null, 2).substring(0, 200)}...`;
            element.appendChild(div);
        }
        
        function clearEventLog() {
            document.getElementById('event-log').innerHTML = '';
        }
        
        // Setup event listeners
        EventBus.on('errorHandler:initialized', () => logEvent('errorHandler:initialized', {}));
        EventBus.on('error:occurred', (data) => logEvent('error:occurred', data));
        EventBus.on('error:contextInvalidated', () => logEvent('error:contextInvalidated', {}));
        EventBus.on('error:contextLost', () => logEvent('error:contextLost', {}));
        EventBus.on('error:contextRestored', () => logEvent('error:contextRestored', {}));
        EventBus.on('error:storage', (data) => logEvent('error:storage', data));
        EventBus.on('selection:cleared', () => logEvent('selection:cleared', {}));
        EventBus.on('highlights:refresh', () => logEvent('highlights:refresh', {}));
        EventBus.on('errorHandler:historyCleared', () => logEvent('errorHandler:historyCleared', {}));
        
        // Initialize StateManager
        StateManager.register('errorHandler', { 
            errorCount: 0, 
            lastError: null, 
            contextValid: true 
        });
        
        // Error simulation functions
        function simulateContextError() {
            try {
                throw new Error('Extension context invalidated');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateContextError', error);
                log(`Context error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        function simulateDOMError() {
            try {
                throw new Error('Cannot read property "parentNode" of null');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateDOMError', error);
                log(`DOM error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        function simulateStorageError() {
            try {
                throw new Error('chrome.storage quota exceeded');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateStorageError', error);
                log(`Storage error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        function simulateSelectionError() {
            try {
                throw new Error('Invalid selection range');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateSelectionError', error);
                log(`Selection error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        function simulateHighlightError() {
            try {
                throw new Error('Failed to create highlight element');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateHighlightError', error);
                log(`Highlight error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        function simulateUnknownError() {
            try {
                throw new Error('Something unexpected happened');
            } catch (error) {
                const recovery = ErrorHandlerModule.handleError('simulateUnknownError', error);
                log(`Unknown error handled. Recovery: ${JSON.stringify(recovery)}`, false, 'simulation-results');
            }
        }
        
        // Safe execution tests
        async function testSafeExecute() {
            const result1 = await ErrorHandlerModule.safeExecute(
                () => 'Success!',
                'testSafeExecute',
                'Fallback'
            );
            log(`Safe execute success: ${result1}`, false, 'safe-exec-results');
            
            const result2 = await ErrorHandlerModule.safeExecute(
                () => { throw new Error('Test error'); },
                'testSafeExecute',
                'Fallback used'
            );
            log(`Safe execute with error: ${result2}`, false, 'safe-exec-results');
        }
        
        async function testSafeExecuteWithRetry() {
            let attempts = 0;
            const result = await ErrorHandlerModule.safeExecute(
                () => {
                    attempts++;
                    if (attempts === 1) {
                        throw new Error('chrome.storage error - retry needed');
                    }
                    return `Success after ${attempts} attempts`;
                },
                'testRetry',
                'Failed after retry'
            );
            log(`Retry test: ${result}`, false, 'safe-exec-results');
        }
        
        async function testWrapFunction() {
            const riskyFunction = (value) => {
                if (value < 0) throw new Error('Negative value not allowed');
                return value * 2;
            };
            
            const safeFunction = ErrorHandlerModule.wrapFunction(riskyFunction, 'testWrap');
            
            const result1 = await safeFunction(5);
            log(`Wrapped function success: ${result1}`, false, 'safe-exec-results');
            
            const result2 = await safeFunction(-5);
            log(`Wrapped function with error: ${result2}`, false, 'safe-exec-results');
        }
        
        // Context tests
        function checkContext() {
            const isValid = ErrorHandlerModule.isContextValid();
            log(`Context is ${isValid ? 'valid' : 'invalid'}`, !isValid, 'context-results');
        }
        
        function mockInvalidContext() {
            // Temporarily remove chrome
            window.chrome = undefined;
            checkContext();
            // Check if error handler detects it
            setTimeout(() => {
                log('Context invalidation should be detected', false, 'context-results');
            }, 1000);
        }
        
        function restoreContext() {
            // Restore chrome
            window.chrome = originalChrome;
            checkContext();
        }
        
        // Statistics
        function showStats() {
            const stats = ErrorHandlerModule.getStats();
            const display = document.getElementById('stats-display');
            
            let html = '<h3>Error Statistics</h3>';
            html += `<div>Total Errors: ${stats.totalErrors}</div>`;
            html += `<div>Context Valid: ${stats.contextValid}</div>`;
            html += `<div>Last Check: ${stats.lastContextCheck}</div>`;
            
            html += '<h4>Errors by Type:</h4>';
            for (const [type, count] of Object.entries(stats.errorsByType)) {
                html += `<div class="error-type">${type}: ${count}</div>`;
            }
            
            html += '<h4>Recent Errors:</h4>';
            stats.recentErrors.forEach(error => {
                html += `<div class="error-entry">`;
                html += `<span class="error-type">[${error.type}]</span> `;
                html += `${error.context}: ${error.message}`;
                html += `</div>`;
            });
            
            display.innerHTML = html;
        }
        
        function clearHistory() {
            ErrorHandlerModule.clearHistory();
            showStats();
            log('Error history cleared', false, 'stats-display');
        }
        
        // Automated tests
        async function testInit() {
            try {
                ErrorHandlerModule.init();
                log('✓ Error handler initialized');
                
                // Check state
                const state = StateManager.get('errorHandler');
                if (state.isInitialized) {
                    log('✓ State properly initialized');
                } else {
                    log('✗ State initialization failed', true);
                }
            } catch (error) {
                log(`✗ Init failed: ${error.message}`, true);
            }
        }
        
        async function testErrorClassification() {
            try {
                const errors = [
                    { error: new Error('Extension context invalidated'), expected: 'CONTEXT_INVALIDATED' },
                    { error: new Error('Cannot read property parentNode'), expected: 'DOM_ERROR' },
                    { error: new Error('chrome.storage error'), expected: 'STORAGE_ERROR' },
                    { error: new Error('Invalid selection range'), expected: 'SELECTION_ERROR' },
                    { error: new Error('Failed to create highlight'), expected: 'HIGHLIGHT_ERROR' },
                    { error: new Error('Random error'), expected: 'UNKNOWN_ERROR' }
                ];
                
                let allPassed = true;
                errors.forEach(({ error, expected }) => {
                    const recovery = ErrorHandlerModule.handleError('testClassification', error);
                    const stats = ErrorHandlerModule.getStats();
                    const lastError = stats.recentErrors[stats.recentErrors.length - 1];
                    
                    if (lastError && lastError.type === expected) {
                        log(`✓ ${expected} correctly classified`);
                    } else {
                        log(`✗ ${expected} classification failed`, true);
                        allPassed = false;
                    }
                });
                
                if (allPassed) {
                    log('✓ All error classifications passed');
                }
            } catch (error) {
                log(`✗ Error classification test failed: ${error.message}`, true);
            }
        }
        
        async function testSuppression() {
            try {
                const suppressedErrors = [
                    new Error('Extension context invalidated'),
                    new Error('Cannot access a chrome:// URL'),
                    new Error('The message port closed')
                ];
                
                const notSuppressedErrors = [
                    new Error('Regular error'),
                    new Error('DOM exception')
                ];
                
                let allPassed = true;
                
                suppressedErrors.forEach(error => {
                    if (ErrorHandlerModule.shouldSuppressError(error)) {
                        log(`✓ "${error.message}" correctly suppressed`);
                    } else {
                        log(`✗ "${error.message}" should be suppressed`, true);
                        allPassed = false;
                    }
                });
                
                notSuppressedErrors.forEach(error => {
                    if (!ErrorHandlerModule.shouldSuppressError(error)) {
                        log(`✓ "${error.message}" correctly not suppressed`);
                    } else {
                        log(`✗ "${error.message}" should not be suppressed`, true);
                        allPassed = false;
                    }
                });
                
            } catch (error) {
                log(`✗ Suppression test failed: ${error.message}`, true);
            }
        }
        
        async function runAllTests() {
            document.getElementById('test-results').innerHTML = '';
            
            log('=== Running Error Handler Module Tests ===');
            
            await testInit();
            await testErrorClassification();
            await testSuppression();
            
            log('=== Tests Complete ===');
            
            // Show final stats
            showStats();
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            ErrorHandlerModule.init();
            log('Error handler module initialized. Use buttons to test error handling.', false, 'simulation-results');
        });
    </script>
</body>
</html>