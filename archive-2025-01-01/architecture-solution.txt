⏺ Based on my research, here's a comprehensive architecture solution for your Chrome extension challenges:

  Recommended Architecture: Event-Driven Modular System

  1. Core Architecture Pattern: Mediator + Pub-Sub

  // mediator.js - Central message broker
  const Mediator = (() => {
    const channels = {};

    return {
      subscribe(channel, callback) {
        if (!channels[channel]) channels[channel] = [];
        channels[channel].push(callback);
        return () => this.unsubscribe(channel, callback);
      },

      publish(channel, data) {
        if (!channels[channel]) return;
        channels[channel].forEach(cb => {
          try { cb(data); }
          catch(e) { console.error(`Error in ${channel}:`, e); }
        });
      }
    };
  })();

  2. Module Structure

  src/
  ├── core/
  │   ├── mediator.js      // Event bus
  │   ├── state-manager.js // Centralized state
  │   ├── error-boundary.js // Global error handling
  │   └── context-guard.js // Extension context validation
  ├── modules/
  │   ├── highlighter/
  │   │   ├── engine.js
  │   │   ├── storage.js
  │   │   └── ui.js
  │   ├── selection/
  │   ├── navigation/
  │   └── analytics/
  └── content.js // Thin entry point

  3. State Management Pattern

  // state-manager.js
  class StateManager {
    constructor(mediator) {
      this.state = {};
      this.mediator = mediator;
    }

    update(path, value) {
      // Immutable update
      const oldValue = this.get(path);
      this.set(path, value);
      this.mediator.publish('state:changed', { path, oldValue, value });
    }
  }

  4. Context Protection Wrapper

  // context-guard.js
  function safeExecute(fn) {
    if (!chrome.runtime?.id) {
      console.warn('Extension context invalidated');
      return;
    }
    try {
      return fn();
    } catch(error) {
      if (error.message.includes('Extension context')) {
        // Graceful degradation
        return;
      }
      throw error;
    }
  }

  5. SPA Navigation Handler

  // navigation-handler.js
  class NavigationHandler {
    constructor(mediator) {
      this.mediator = mediator;
      this.observeSPAChanges();
    }

    observeSPAChanges() {
      // Observe URL changes
      let lastUrl = location.href;
      new MutationObserver(() => {
        if (location.href !== lastUrl) {
          lastUrl = location.href;
          this.mediator.publish('navigation:changed', { url: lastUrl });
        }
      }).observe(document, { subtree: true, childList: true });

      // Intercept History API
      ['pushState', 'replaceState'].forEach(method => {
        const original = history[method];
        history[method] = function() {
          const result = original.apply(history, arguments);
          window.dispatchEvent(new Event('locationchange'));
          return result;
        };
      });
    }
  }

  6. Module Communication Example

  // highlighter/engine.js
  export class HighlightEngine {
    constructor(mediator) {
      this.mediator = mediator;
      this.mediator.subscribe('selection:made', this.handleSelection.bind(this));
      this.mediator.subscribe('navigation:changed', this.reinitialize.bind(this));
    }

    handleSelection(data) {
      safeExecute(() => {
        // Process selection
        const highlight = this.createHighlight(data);
        this.mediator.publish('highlight:created', highlight);
      });
    }
  }

  7. Benefits for Your Use Case

  Solves Your Issues:
  - 900+ lines of troubleshooting → Isolated modules with error boundaries
  - Flicker problems → State-driven UI updates via mediator
  - Context invalidation → Centralized context checking
  - DOM nightmares → DOM operations isolated in specific modules
  - SPA chaos → Dedicated navigation handler with state persistence
  - 1500+ line file → Split into 10-15 focused modules (100-150 lines each)

  Future-Proof for Pro Features:
  - AI Integration → New module publishes to 'ai:request' channel
  - Cloud Sync → Sync module subscribes to 'state:changed'
  - Analytics → Analytics module subscribes to all user actions
  - Collaboration → Real-time module publishes/subscribes to shared events

  8. Migration Strategy

  1. Wrap existing code in modules without changing logic
  2. Gradually refactor each module to use mediator
  3. Add new features as separate modules
  4. No full rewrite needed - incremental improvement

  This architecture has been battle-tested in large-scale applications and specifically addresses Chrome extension constraints while
  maintaining vanilla JavaScript performance.